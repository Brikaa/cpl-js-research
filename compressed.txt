Dynamic type binding :-
The JavaScript interpreter assigns a variable a changeable type at runtime based on its context.
When defining functions, the parameter types are determined at runtime at each call.
Arrays can have elements of different types.

Type checking :-
When the types of variables mismatch, the interpreter tries to convert the type of one variable into the other.
Even strings can be coerced into numbers and vice-versa (1 + "2" = "12"). This is known as weak typing
When a type can not be coerced into another type, JavaScript throws a TypeError at runtime (12(), 12 is not a function).

Dynamic storage binding :-
Most variables in are implicit heap-dynamic variables since they bind to both type and storage when they are
assigned values.
Pointers to these variables are stored on the stack.
The JavaScript engine can do optimizations before runtime and choose to allocate some variables on the stack.
If a variable on the heap is not referenced anymore, the garbage collector deallocates it.

Side effects :-
A function can modify non-local variables, and it can modify objects its parameters are pointing to.
Note that this is different from pass-by-reference in C++ since the actual references are not modified.
It is impossible to do swap(x, y) in JavaScript, but it is possible to do sort(arr).

Named constants :-
Although the `const` keyword exists, it neither means 'named constant' nor 'read-only'.
It means a variable can not be re-assigned.
Therefore, one can change the elements of a const array, but can not reassign it to a new array.

Expressivity and interesting operators :-
If we want to assign some values in an array to variables, we can do so with the shorthand destructuring assignment:
```
let arr = [1, 2, 3];
let [a, b, c] = arr;
```
which has the same result as "a = arr[0], b = arr[1], c = arr[2]".
A similar syntax exists with objects.

If we want to spread an array into another array, we can do so expressively with the spread syntax:
```
let a = [2,3,4];
console.log([1, ...a, 5, 6]); // expected output: [1, 2, 3, 4, 5, 6]
```

Lack of orthogonality :-
The `typeof` operator returns the type of a value as a string.
If the value is a primitive data type (one of: number, string, boolean, bigint, symbol, null, undefined),
it returns (should return) the name of that data type.
If the value is a non-primitive data type, it either returns `object` or `function`.

One special case is `typeof null`; it returns `object`.
This is a bug in the language's implementations that was not fixed for backward compatibility.
`typeof null` should be null since `null` is a primitive data type.

The programmer has to be aware that checking null types is done differently.
They should compare the nullish variable directly against null (someNullishVar === null).

Syntax design problems :-
`var` is used to hoist a local variable; that is, the declaration executes before any code in the function is executed.
However, the keyword `var` is shorthand for `variable`. The keyword does not hint at the fact that
the variable is hoisted.

`let` is used to declare a block-scoped variable.
It is inspired from the mathematical keyword `let`.
It does not hint at the fact that the variable is block-scoped (or that it is different from `var`)

`const` is used to declare a block-scoped constant.
However, it is not like constants in other languages as discussed in (Named constants).

The programmer can choose not to insert a semicolon at the end of a statement and only insert a new line.
The engine will automatically insert a semi-colon.
However, this causes ambiguity if two lines are legal with or without a semicolon between them.
```
return  // semicolon automatically inserted here (unintended)
    1 + 2
```

Exception handling :-
The code that is expected to raise an exception is surrounded with try..catch, try..finally or try..catch..finally.
JavaScript tries to execute the code in the `try` block.
If the code raises an exception, the control flow is moved to the `catch` block.
The code in the finally block executes regardless whether the code raised an exception or didn't
and whether there existed a catch block that caught this exception or not.

Due to JavaScriptâ€™s dynamic typing, we have to use if conditions
to check for the exception type after catching it and to re-throw it if it is an unexpected type.
This is different to how exceptions are caught in languages like C++ and Java
where the exception type is mentioned explicitly in the catch statement.
