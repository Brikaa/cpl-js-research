\documentclass[11pt,a4paper]{article}
\usepackage{hyperref}

\begin{document}
\title{Evaluation of different JavaScript characteristics}
\author{Omar Adel Brikaa - 20206043\thanks{Omar Adel Abdel Hamid Ahmed Brikaa - S5 - brikaaomar@gmail.com}}
\date{}
\maketitle

\tableofcontents

\section{Introduction}
Javascript is a dynamically-typed, multi-purpose, multi-paradigm programming language.
It has been mainly used to run client-side code on web browsers.
It has also grown into other areas of programming such as web server back-end programming\footnote{https://nodejs.org/en/}.
In this article, I evaluate some different characteristics of JavaScript including:
types, expressivity, orthogonality, simplicity, syntax design and exception handling.

\section{Types}

\subsection{\label{dynamic_typing}Dynamic typing}
The JavaScript interpreter assigns a variable a type at runtime based on its value.
\begin{verbatim}
    let a = "foo";
    console.log(typeof a); // "string"
    a = true;
    console.log(typeof a); // "boolean"
    a = 12;
    console.log(typeof a); // "number"
    a = { hello: "world" };
    console.log(typeof a); // "object"
\end{verbatim}
When defining a function, the parameters types are determined at runtime at each call:
\begin{verbatim}
    function add(a, b) {
        return a + b;
    }
    console.log(add(1, 2)); // 3
    console.log(add("hello ", "world")); // hello world
\end{verbatim}
Arrays can have elements of different types:
\begin{verbatim}
    const arr = [1, "foo", true, { hello: "world" }];
    arr.forEach((x) => console.log(typeof x));
    // Expected output:
    // number
    // string
    // boolean
    // object
\end{verbatim}

\subsection{Weak typing}
When the types of variables mismatch, the interpreter tries to convert the type of one variable into the other.
This is known as type coercion.
\begin{verbatim}
    const a = "1";
    const b = 2;
    console.log(a + b);
    // "12", b was coerced into a string

    const arr = [1,2,3];
    console.log(arr.slice("1"));
    // [2,3], "1" was coerced into a number
\end{verbatim}

\subsection{Type checking}
When a type can not be coerced into another type, JavaScript throws a TypeError at runtime.
\begin{verbatim}
    const a = null;
    a.sayHello(); // TypeError: cannot read properties of null

    const b = 12;
    b(); // TypeError: b is not a function
\end{verbatim}

\section{Expressivity}
Expressivity is the ability to perform multiple computations using compact syntax.
Following are some examples of expressivity in Javascript:

\subsection{Compound assignment operators}
Like many other programming languages, JavaScript supports assigning a value to a variable based on its previous value
without repeating the variable name. The following are equivalent pieces of code:
\begin{verbatim}
    a = a + 1;
    a += 1;

    b = b * 1;
    b *= 1

    c = c + " world"
    c += " world"
\end{verbatim}

\subsection{Postfix and prefix increment, decrement}
JavaScript also supports incrementing and decrementing variables by one without the usage of compound assignment
operators:
\begin{verbatim}
    a += 1;
    a++;

    b -= 1;
    b--;

    let d = c; c += 1;
    let d = c++;

    f += 1; let e = f;
    let e = ++f;
\end{verbatim}

\subsection{Destructuring assignment}
If we want to assign some values in an array to variables, we can do so with a shorthand syntax:
\begin{verbatim}
    let arr = [1, 2, 3];
    let [a, b, c] = arr; // instead of:
    a = arr[0];
    b = arr[1];
    c = arr[2];
\end{verbatim}
Note that the variables must be ordered in the same way the values are in the array.
The same can be done with objects\footnote{Objects are discussed in detail in other sections}:
\begin{verbatim}
    let obj = {
        a: "Hello",
        b: "World"
    };
    let {a, b} = obj; // instead of
    a = obj.a;
    b = obj.b;
\end{verbatim}
Note that the variables must have the same name of the objects member names. Destructuring assignment can be used in more
powerful ways that are discussed in other sections.

\subsection{\label{spread_syntax}Spread syntax}
If we want to spread an array into another array, we can do so expressively with the spread syntax:
\begin{verbatim}
    let a = [2,3,4];
    console.log([1, ...a, 5, 6]);
    // expected output: [1, 2, 3, 4, 5, 6]
\end{verbatim}
More powerful usages of the spread syntax are discussed in other sections.

\subsection{\label{arrow_functions}Arrow functions}
JavaScript uses the `function' keyword to define a function; however, a more concise syntax has been introduced in
ES6\footnote{https://en.wikipedia.org/wiki/ECMAScript}. The new arrow function syntax is not only syntactically
different from the traditional function syntax; there are other differences which are discussed in other sections:
\begin{verbatim}
    // Traditional syntax
    function power(a) {
        return a * a;
    }

    // Arrow function
    const power1 = (a) => {
        return a * a;
    }

    // The curly braces can be omitted
    // Since the function directly returns a value
    const power2 = (a) => a * a;

    // The parentheses around the parameter
    // can also be omitted since it is only
    // one parameter
    const power3 = a => a * a;
\end{verbatim}

\subsection{\label{for_of_for_in}for..of, for..in}
JavaScript provides expressive control statements that helps in iterating over an array:
\begin{verbatim}
    for (const i of [1, 2, 3, 4]) {
        console.log(i);
    }
    // instead of
    const arr = [1, 2, 3, 4];
    for (let i = 0; i < arr.length; ++i) {
        console.log(arr[i]);
    }
\end{verbatim}
It also provides compact syntax for iterating over an Object's keys
\begin{verbatim}
    let person = {
        name: "foo",
        age: 13,
    }
    for (const key in person) {
        console.log(person[key]);
    }
\end{verbatim}

\subsection{\label{fp_functions}Functions inspired by functional programming}
JavaScript has multiple functions that are inspired by expressive functions in functional programming languages like
Haskell.
For example, the map function takes an array and a unary
function\footnote{Functions can be passed as parameters to other functions, this is discussed in another section}
and returns an array that is the result of applying the function on each element in the given array:
\begin{verbatim}
    // Note the use of the arrow function syntax
    // And the definition of the map function on the fly
    let arr = [1, 2, 3].map(x => x * 2);
    // instead of
    let arr = [];
    for (const i of [1, 2, 3]) {
        arr.push(i * 2);
    }
\end{verbatim}
JavaScript also has a filter function that, given an array and a unary function,
returns a new array containing the elements on which the unary function returns true:
\begin{verbatim}
    const even = [1, 2, 3, 4, 5].filter(x => x % 2 === 0);
    console.log(even);
    // Expected output: [2, 4]
\end{verbatim}

\section{Orthogonality}
Orthogonality is the ability to combine different constructs in a meaningful way without the need for special handling.
I discuss some examples of orthogonality and lack of thereof in JavaScript:

\subsection{\label{objects}Objects}
JavaScript contains seven primitive data types: string, number, bigint, boolean, symbol, undefined and null.
Every non-primitive data type is an object,
and every primitive data type (except for null and undefined) has an object wrapper.
This allows for consistency while dealing with different data types and data structures.

An object is a collection of properties, and a property is an association between a name (or key) and a value.
A property's value can be a
function\footnote{\raggedright \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects}}.
The following is an example of an object:
\begin{verbatim}
    const obj = {
        name: "foo",
        sayName() {
            console.log("My name is " + this.name)
        }
    };

    obj.sayName(); // My name is foo
\end{verbatim}
Since every non-primitive type is an object, it is worth noting that
a function is an object with the additional capability of being callable,
and an array is an object with iterable integer-keyed properties that determine its length.

\subsection{\label{functions_first_class}Functions as first-class objects}
Functions can be treated as any other object.
They can be assigned to variables and constants, passed to other functions as parameters
and returned from other functions.
In fact, the arrow function example in \ref{arrow_functions}
assigns an anonymous function (a function without a name) to a constant (power1, power2, power3).

This is a functional programming principle known as "functions as first-class citizens".
Section \ref{fp_functions} briefly hints to this principle.
The following is an example that shows features that have been discussed in
\ref{arrow_functions}, \ref{dynamic_typing}, \ref{for_of_for_in}, \ref{functions_first_class}, \ref{objects}:
\begin{verbatim}
    // Assigning an anonymous function to a constant
    const add = (a, b) => a + b;
    const subtract = (a, b) => a - b;
    const multiply = (a, b) => a * b;

    // A function that returns the appropriate operation
    // function according to the opString
    const chooseOperation = (opString) => {
        // Using an object to store the functions
        // keyed by their opString
        const ops = {
            "+": add,
            "-": subtract,
            "*": multiply
        };
        return ops[opString];
    }

    // A function that takes an operation
    // and its two arguments as arguments
    // and applies the operation to these arguments
    const applyOperation = (op, a, b) => op(a, b);

    const expr1 = "1 + 2";
    const expr2 = "2 * 3";
    const expr3 = "3 - 2";

    // For..of loop
    for (const expr of [expr1, expr2, expr3]) {
        // Destructuring assignment
        let [a, op, b] = expr.split(" ");
        // Dynamic typing, can change the value type
        // at runtime
        a = parseInt(a);
        b = parseInt(b);
        op = chooseOperation(op);
        console.log(applyOperation(op, a, b));
    }

    // Expected output:
    // 3
    // 6
    // 1
\end{verbatim}

\subsection{Spread syntax in different contexts}
The spread syntax discussed in \ref{spread_syntax} can be used consistently in different contexts.
It can be used to merge objects:
\begin{verbatim}
    const a = { fruit: "apple" };
    const b = { vegetable: "potato" }
    const c = { ...a, ...b };
    console.log(c);
    // { fruit: "apple", vegetable: "potato" }
\end{verbatim}
Since an array is an object, the spread syntax can be used to merge an array:
\begin{verbatim}
    const a = [1, 2, 3];
    const b = [4, 5, 6];
    const c = [...a, ...b];
    console.log(c);
    // [1, 2, 3, 4, 5, 6]
\end{verbatim}
It can be used to make a function accept an infinite number of parameters:
\begin{verbatim}
    // reduce is another functional programming
    // inspired function
    const multiply = (...xs) =>
        xs.reduce((acc, x) => acc * x, 1);

    console.log(multiply(2, 3)); // 6
    console.log(multiply(2, 3, 4)); // 24
\end{verbatim}

\subsection{Destructuring assignment in different contexts}
Likewise, the destructuring assignment can be used consistently in different contexts.
It can be in iterators like for..of:
\begin{verbatim}
    const objects = [
        { fruit: "apple", vegetable: "potato" },
        { fruit: "banana", vegetable: "pea" },
        { fruit: "pineapple", vegetable: "okra" }
    ];

    // Destructuring fruit and vegetable
    // from each object
    for ({ fruit, vegetable } of objects) {
        console.log(
            "The fruit is "
            + fruit +
            " and the vegetable is " + vegetable
        );
    }
    // Expected output:
    // The fruit is apple and the vegetable is potato
    // The fruit is banana and the vegetable is pea
    // The fruit is pineapple and the vegetable is okra
\end{verbatim}
It can be used in function parameters:
\begin{verbatim}
    const sayFoodInfo = ({ fruit, vegetable }) => {
        console.log(
            "The fruit is "
            + fruit
            + " and the vegetable is "
            + vegetable
        );
    }

    sayFoodInfo({ fruit: "date", vegetable: "tomato" })
    // Expected output:
    // The fruit is date and the vegetable is tomato
\end{verbatim}

\subsection{Destructuring assignment in tandem with spread syntax}
The destructuring assignment can be used in tandem with the spread syntax to
destructure the first n items of an array and put the remaining items in a second array
where n is the number of variables not preceded by `...' in the destructuring assignment.

Consider the following function that gets the last element in an array without using the length property nor indexing:
\begin{verbatim}
    // The parameters destructure the array
    // into the first element
    // and a second array containing the rest
    // of the elements
    const last = ([x, ...xs]) => {
        // Nothing could be destructured
        // (empty array)
        if (x === undefined)
            return [];
        // Nothing could be destructured from xs
        // Only one element, return it
        const [y] = xs;
        if (y === undefined)
            return x;
        // Still no base cases
        // last is the last of the remaining elements
        return last(xs);
    }

    console.log(last([1, 2, 3, 4, 5, 6])); // 6
\end{verbatim}

\subsection{typeof null (lack of orthogonality)}
The `typeof' JavaScript operator returns the type of a value in a string.
If the value is a primitive data type (\ref{objects}), it returns the name of that data type.
If the value is a non-primitive data type, it either returns `object' or
`function'\footnote{It does that although a function is an object, but that is another matter I will not discuss.}

One special case is `typeof null' or `typeof someNullishVariable'; it returns `object'.
This is a bug in the language's implementations that was not fixed due to the need for backward compatibility.
`typeof null' should be null since null is a primitive data type.

This leads to a lack of orthogonality when checking for nullish variables:
\begin{verbatim}
    for (const a of ["Hello", undefined, null, 123]) {
        if (typeof a === "string")
            console.log("a is a string");
        else if (typeof a === "undefined")
            console.log("a is undefined");
        // Notice how we need to handle nulls
        // differently here
        else if (a === null)
            console.log("a is null");
        else
            console.log("a is another data type");
    }
    // Expected output:
    // a is a string
    // a is undefined
    // a is null
    // a is another data type
\end{verbatim}

\section{Simplicity}
A programming language is simple if it consists of a small set of constructs to be learnt.
Because JavaScript is a fast-growing language with focus on backward compatibility,
many sacrifices to simplicity had to be made.
There exists many methods of doing the same thing in JavaScript.
A JavaScript programmer is expected to know many of them in order to be able to read JavaScript codebases.
The following are some examples of lack of simplicity in JavaScript:

\subsection{`this' keyword}
`this' keyword in JavaScript is used to refer to the current object but it behaves differently depending on where
it is used as shown in the following examples:

\subsubsection{`this' keyword in traditional functions}
The example in section \ref{objects} used `this' keyword to refer to the object in the `sayName' method.
The following modification to the example, however, will produce a wrong result:
\begin{verbatim}
    const obj = {
        name: "foo",
        sayName() {
            console.log("My name is " + this.name)
        }
    };

    const sayName = obj.sayName;
    sayName(); // My name is [different output]
\end{verbatim}

The last two lines in the code snippet were modified to assign the `obj.sayName' function to a constant,
and call the function using this constant.
The correct name was not outputted since `this' did not get bounded to the object.

When using traditional functions (not arrow functions) inside the object and calling them,
`this' gets bound to the object before the dot in the call.
In the above case, there was no object before the dot; hence it was bound to the global window object.
In fact, if the global window object contains a name property, it will be used:
\begin{verbatim}
    const obj = {
        name: "foo",
        sayName() {
            console.log("My name is " + this.name);
        }
    };

    window.name = "fake";

    const sayName = obj.sayName
    sayName(); // My name is fake
\end{verbatim}

\subsubsection{`this' keyword in arrow functions}
When using arrow functions inside an object and calling them, `this' is not bound to the function,
but rather gets its value from the outer scope:

\begin{verbatim}
    const obj = {
        name: "foo",
        sayName: () => {
            console.log("My name is " + this.name);
        }
    };

    window.name = "fake";
    obj.sayName(); // My name is fake
\end{verbatim}
In the above example, no value got bound to `this' in `sayName'; so the global `window' object was used.

The following example uses a traditional function in `sayName' that
returns an arrow function (\ref{functions_first_class}) which uses `this'.
\begin{verbatim}
    const obj = {
        name: "foo",
        sayName() {
            return () => {
                console.log("My name is " + this.name);
            }
        }
    };

    window.name = "fake";
    (obj.sayName())(); // My name is foo
\end{verbatim}
It produces the correct output since `this' got bound to `obj' in the traditional function,
and took the value of `obj' in the returned arrow function.

\subsubsection{`this' keyword with `new'}
When using the `this' inside a traditional function and using the `new' operator while calling this function,
`this' gets bound to a new empty object which the function automatically returns.
The type of function that is used solely for this purpose is known as a `constructor':
\begin{verbatim}
    function Obj() {
        this.name = "foo";
        this.sayName = () => {
            console.log("My name is " + this.name);
        }
    }

    const obj = new Obj();
    obj.sayName(); // My name is foo
\end{verbatim}

\end{document}
